// the regfile for all the game information
module miniRegfiles (
    input clk,  // clock
    input rst,  // reset
    input write_address[4], // write address
    input we, // write enable
    input data[16], // data in
    
    
    input read_address_a[4], //address port a
    input read_address_b[4], //address port b
    output out_a[16], //read port a
    output out_b[16], //read port b
    output p1display[2],
    output p2display[2],
    output p1_selection[2],
    output p2_selection[2],
    output msps[2]
    
    //debug
    //output timer[16],
    //output all_scores[32],
    //output all_buttons[4],
    //output counter_out[16]
    
  )
  
  {
  .clk(clk){
    .rst(rst){
      dff p1buttonreg[16] (#INIT(0), .clk(clk), .rst(rst)); //P1 button count reg
      dff p2buttonreg[16] (#INIT(0), .clk(clk), .rst(rst)); //P2 button count reg
      dff p1selectionreg[2] (#INIT(0), .clk(clk), .rst(rst)); //P1 Selection reg
      dff p2selectionreg[2] (#INIT(0), .clk(clk), .rst(rst)); //P2 Selection reg
      dff helmet[16] (#INIT(0), .clk(clk), .rst(rst)); //who is helmet
      dff hammer[16] (#INIT(0), .clk(clk), .rst(rst)); //who is hemmer
      dff p1scorereg[2](#INIT(0), .clk(clk), .rst(rst)); // P1 score output led
      dff p2scorereg[2](#INIT(0), .clk(clk), .rst(rst)); // P2 score output led
      dff inc_counterreg[16] (#INIT(0), .clk(clk), .rst(rst)); //store the current count
      dff modreg[2] (#INIT(0), .clk(clk), .rst(rst)); //store which led to light up
      //dff alufnreg[6](#INIT(0), .clk(clk), .rst(rst)); // store 6 bit alufn
      dff ledstart[16] (#INIT(0), .clk(clk), .rst(rst)); // when to start the main led
      dff temp_var[16] (#INIT(0));
      dff plus1reg[16] (#INIT(0));
    }
  }
  
  always {
    
    
    if (we){
      case(write_address){
        b0000 : p1buttonreg.d = data;
        b0001 : p2buttonreg.d = data;
        b0010 : p1selectionreg.d= data;
        b0011 : p2selectionreg.d = data;
        b0100 : helmet.d = data;
        b0101 : hammer.d = data;
        b0110 : p1scorereg.d = data;
        b0111 : p2scorereg.d = data;
        b1000 : inc_counterreg.d = data;
        b1001 : modreg.d = data;
        b1010 : ledstart.d = data;
        b1011 : plus1reg.d = data;
        b1111 : temp_var.d = data;
      }
    }
    
    //read port a
    case(read_address_a){
      b0000 : out_a = p1buttonreg.q;
      b0001 : out_a = p2buttonreg.q;
      b0010 : out_a = p1selectionreg.q;
      b0011 : out_a = p2selectionreg.q;
      b0100 : out_a = helmet.q;
      b0101 : out_a = hammer.q;
      b0110 : out_a = p1scorereg.q;
      b0111 : out_a = p2scorereg.q;
      b1000 : out_a = inc_counterreg.q;
      b1001 : out_a = modreg.q;
      b1010 : out_a = ledstart.q;
      b1011: out_a = plus1reg.q;
      b1111 : out_a = temp_var.q;
      default : out_a = 0;
    }
    
    //read port b
    case(read_address_b){
      b0000 : out_b = p1buttonreg.q;
      b0001 : out_b = p2buttonreg.q;
      b0010 : out_b = p1selectionreg.q;
      b0011 : out_b = p2selectionreg.q;
      b0100 : out_b = helmet.q;
      b0101 : out_b = hammer.q;
      b0110 : out_b = p1scorereg.q;
      b0111 : out_b = p2scorereg.q;
      b1000 : out_b = inc_counterreg.q;
      b1001 : out_b = modreg.q;
      b1010 : out_b = ledstart.q;
      b1011 : out_b = plus1reg.q;
      b1111 : out_b = temp_var.q;
      default : out_b = 0;
    }
    
    
    p1display = p1scorereg.q;
    p2display = p2scorereg.q;
    p1_selection = p1selectionreg.q;
    p2_selection = p2selectionreg.q;
    msps = plus1reg.q;
    
    //For debugging
    //all_scores[15:0] = p1_score.q;
    //all_scores[31:16] = p2_score.q;
    //all_buttons[1:0] = p1_buttonPress.q[1:0];
    //all_buttons[3:2] = p2_buttonPress.q[1:0];
    //timer = current_timer.q;
    //counter_out = current_counter.q;
  }
}